"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sumNumeric = exports.avg = exports.stdDev = exports.findIndexFromRight = exports.getOrNew = exports.getOrCreate = exports.missing = exports.duplicates = exports.pushFrom = exports.groupByThree = exports.groupByBoolean = exports.modulo = exports.sum = exports.sortAscending = exports.sortDescending = exports.SwapPair = void 0;
class SwapPair {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    map(f) {
        return new SwapPair(f(this.from), f(this.to));
    }
}
exports.SwapPair = SwapPair;
function sortDescending(array, sizeOf) {
    return array.sort((left, right) => sizeOf(right) - sizeOf(left));
}
exports.sortDescending = sortDescending;
function sortAscending(array, sizeOf) {
    return array.sort((left, right) => sizeOf(left) - sizeOf(right));
}
exports.sortAscending = sortAscending;
function sum(array, sizeOf) {
    return array.reduce((acc, cur) => acc += sizeOf(cur), 0);
}
exports.sum = sum;
function modulo(dividend, divisor) {
    return ((dividend % divisor) + divisor) % divisor;
}
exports.modulo = modulo;
function groupByBoolean(array, predicate) {
    return array.reduce((acc, t) => {
        acc[boolToInt(predicate(t))].push(t);
        return acc;
    }, [[], []]);
}
exports.groupByBoolean = groupByBoolean;
function boolToInt(bool) {
    return bool ? 1 : 0;
}
function groupByThree(array, index) {
    return array.reduce((acc, t) => {
        acc[index(t)].push(t);
        return acc;
    }, [[], [], []]);
}
exports.groupByThree = groupByThree;
function pushFrom(index, from, to) {
    to.push(from.splice(index, 1)[0]);
}
exports.pushFrom = pushFrom;
function duplicates(array, hash) {
    const duplicates = Array.from(array);
    new Map(array.map(t => [hash(t), t])).forEach((_t, h) => {
        duplicates.splice(duplicates.findIndex(dupT => h === hash(dupT)), 1);
    });
    return duplicates;
}
exports.duplicates = duplicates;
function missing(all, subset, hash) {
    const missing = Array.from(all);
    for (const t of subset) {
        missing.splice(missing.findIndex(other => hash(other) === hash(t)), 1);
    }
    return missing;
}
exports.missing = missing;
function getOrCreate(map, key, valueSupplier, initializer) {
    let value = map.get(key);
    if (value == undefined) {
        value = valueSupplier();
        map.set(key, value);
        if (initializer !== undefined) {
            initializer(value);
        }
    }
    return value;
}
exports.getOrCreate = getOrCreate;
function getOrNew(map, key, valueSupplier) {
    const value = map.get(key);
    return value !== undefined ? value : valueSupplier();
}
exports.getOrNew = getOrNew;
function findIndexFromRight(arr, condition) {
    if (arr.length === 0) {
        return -1;
    }
    for (let i = arr.length - 1; 0 <= i; --i) {
        if (condition(arr[i])) {
            return i;
        }
    }
    return -1;
}
exports.findIndexFromRight = findIndexFromRight;
function stdDev(array) {
    if (array.length === 0) {
        return 0;
    }
    const mean = avg(array);
    return Math.sqrt(sumNumeric(array.map(x => Math.pow(x - mean, 2))) / array.length);
}
exports.stdDev = stdDev;
function avg(array) {
    return array.length === 0 ? 0 : sumNumeric(array) / array.length;
}
exports.avg = avg;
function sumNumeric(array) {
    return array.length === 0 ? 0 : array.reduce((a, b) => a + b);
}
exports.sumNumeric = sumNumeric;
