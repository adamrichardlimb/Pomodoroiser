"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.adaptToNumberIterable = exports.isIterable = exports.toArray = exports.prepareValuesNoCapacity = exports.prepareValues = void 0;
function prepareValues(obj, sizeOf, capacity) {
    if (validateNumber(capacity, 'capacity') <= 0) {
        throw new Error('Capacity must be a positive number');
    }
    const array = toArray(obj);
    const oversized = [];
    const oversizedIndexes = [];
    const iter = array.entries();
    let nextObj = iter.next();
    while (!nextObj.done) {
        const index = nextObj.value[0];
        const element = nextObj.value[1];
        const size = sizeOf(element);
        validateNumber(size, index);
        if (size > capacity) {
            oversized.push(element);
            oversizedIndexes.push(index);
        }
        nextObj = iter.next();
    }
    for (const index of oversizedIndexes.reverse()) {
        array.splice(index, 1);
    }
    return { array: array, oversized: oversized, };
}
exports.prepareValues = prepareValues;
function prepareValuesNoCapacity(obj, sizeOf) {
    const array = toArray(obj);
    const iter = array.entries();
    for (let nextObj = iter.next(); !nextObj.done; nextObj = iter.next()) {
        const index = nextObj.value[0];
        const element = nextObj.value[1];
        validateNumber(sizeOf(element), index);
    }
    return array;
}
exports.prepareValuesNoCapacity = prepareValuesNoCapacity;
function toArray(obj) {
    if (Array.isArray(obj)) {
        return obj;
    }
    else {
        return Array.from(toIterable(obj));
    }
}
exports.toArray = toArray;
function toIterable(obj) {
    if (obj !== null) {
        if (isIterable(obj)) {
            return obj;
        }
        else if (typeof obj === 'object') {
            return Object.values(obj);
        }
    }
    throw new Error('Must be either iterable or a non-function object');
}
function isIterable(obj) {
    return typeof obj[Symbol.iterator] === 'function';
}
exports.isIterable = isIterable;
function validateNumber(num, context) {
    if (num === null || num === undefined || typeof num !== 'number') {
        throw new Error(`Expected a number for ${context}`);
    }
    else {
        return num;
    }
}
function adaptToNumberIterable(capacity) {
    if (typeof capacity === 'number') {
        return (function* () {
            while (true) {
                yield capacity;
            }
        })();
    }
    if (isIterable(capacity)) {
        return capacity;
    }
    if (typeof capacity === 'function') {
        const called = capacity();
        if (isIterable(called)) {
            return called;
        }
    }
    throw new Error('Capacity must be one of: number, iterable, or generator');
}
exports.adaptToNumberIterable = adaptToNumberIterable;
