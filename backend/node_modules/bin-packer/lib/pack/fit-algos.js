"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bestFitDecreasingSorted = exports.bestFitDecreasing = exports.firstFitDecreasing = exports.firstFit = exports.nextFit = void 0;
const binary_apply_1 = require("../util/binary-apply");
const prepare_values_1 = require("../util/prepare-values");
const utils_1 = require("../util/utils");
function nextFit(obj, sizeOf, capacity) {
    const { array: array, oversized: oversized } = prepare_values_1.prepareValues(obj, sizeOf, capacity);
    const bins = [];
    let currentBinUtilization = capacity + 1;
    let blockNum = -1;
    for (const value of array) {
        const size = sizeOf(value);
        currentBinUtilization += size;
        if (currentBinUtilization > capacity) {
            ++blockNum;
            bins[blockNum] = [];
            currentBinUtilization = size;
        }
        bins[blockNum].push(value);
    }
    return { bins: bins, oversized: oversized, };
}
exports.nextFit = nextFit;
function firstFit(obj, sizeOf, capacity) {
    return firstFitArray(obj, sizeOf, capacity, false);
}
exports.firstFit = firstFit;
function firstFitDecreasing(obj, sizeOf, capacity) {
    return firstFitArray(obj, sizeOf, capacity, true);
}
exports.firstFitDecreasing = firstFitDecreasing;
function firstFitArray(obj, sizeOf, capacity, presort) {
    const { array: array, oversized: oversized } = prepare_values_1.prepareValues(obj, sizeOf, capacity);
    const bins = [];
    const remaining = [];
    if (presort) {
        utils_1.sortDescending(array, sizeOf);
    }
    for (const value of array) {
        const size = sizeOf(value);
        let createNewBin = true;
        for (let i = 0; i < bins.length; ++i) {
            if (size <= remaining[i]) {
                bins[i].push(value);
                remaining[i] -= size;
                createNewBin = false;
                break;
            }
        }
        if (createNewBin) {
            bins[bins.length] = [];
            bins[bins.length - 1].push(value);
            remaining[bins.length - 1] = capacity - size;
        }
    }
    return { 'bins': bins, 'oversized': oversized, };
}
class SizedBin {
    constructor() {
        this.bin = [];
        this.size = 0;
    }
    static extractBins(sizedBins) {
        return sizedBins.map(sizedBin => sizedBin.bin);
    }
}
function bestFitDecreasing(obj, sizeOf, capacity) {
    const { array: array, oversized: oversized } = prepare_values_1.prepareValues(obj, sizeOf, capacity);
    return {
        'bins': bestFitDecreasingSorted(utils_1.sortDescending(array, sizeOf), sizeOf, capacity),
        'oversized': oversized,
    };
}
exports.bestFitDecreasing = bestFitDecreasing;
function bestFitDecreasingSorted(sorted, sizeOf, capacity) {
    const itemLeq = (item, _, bin) => sizeOf(item) <= capacity - bin.size;
    const itemInsert = (item, sizedBins, i) => {
        if (i >= sizedBins.length) {
            sizedBins.push(new SizedBin());
        }
        sizedBins[i].size += sizeOf(item);
        sizedBins[i].bin.push(item);
    };
    const binMoreFull = (currentIndex, sizedBins, bin) => sizedBins[currentIndex].size >= bin.size;
    const binResort = (currentIndex, sizedBins, i) => {
        if (i === currentIndex) {
            return;
        }
        if (i > currentIndex) {
            throw new Error(`Algorithm error: newIndex ${i} > currentIndex ${currentIndex}`);
        }
        const binToMove = sizedBins[currentIndex];
        sizedBins.copyWithin(i + 1, i, currentIndex);
        sizedBins[i] = binToMove;
    };
    const bins = [];
    for (const value of sorted) {
        const binIndex = binary_apply_1.binaryApply(bins, value, itemLeq, itemInsert);
        binary_apply_1.binaryApply(bins, binIndex, binMoreFull, binResort);
    }
    return SizedBin.extractBins(bins);
}
exports.bestFitDecreasingSorted = bestFitDecreasingSorted;
