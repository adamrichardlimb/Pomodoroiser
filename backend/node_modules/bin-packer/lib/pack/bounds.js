"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lowerBound2Sorted = exports.lowerBound2 = exports.lowerBound1 = void 0;
const prepare_values_1 = require("../util/prepare-values");
const utils_1 = require("../util/utils");
function lowerBound1(obj, sizeOf, capacity) {
    const { array: array, oversized: oversized } = prepare_values_1.prepareValues(obj, sizeOf, capacity);
    return {
        'bound': Math.ceil(utils_1.sum(array, sizeOf) / capacity),
        'oversized': oversized.length,
    };
}
exports.lowerBound1 = lowerBound1;
function lowerBound2(obj, sizeOf, capacity) {
    const { array: array, oversized: oversized } = prepare_values_1.prepareValues(obj, sizeOf, capacity);
    return {
        'bound': lowerBound2Sorted(utils_1.sortAscending(array, sizeOf), sizeOf, capacity),
        'oversized': oversized.length,
    };
}
exports.lowerBound2 = lowerBound2;
function lowerBound2Sorted(sortedArray, sizeOf, capacity) {
    let waste = 0;
    let carry = 0;
    let elementTotal = 0;
    const constSizeOf = sizeOf;
    while (sortedArray.length > 0) {
        const largestSize = sizeOf(sortedArray.pop());
        elementTotal += largestSize;
        const remainder = capacity - largestSize;
        const firstLargerThanRemainder = sortedArray.findIndex(function (element) {
            return constSizeOf(element) > remainder;
        });
        const smallerCount = firstLargerThanRemainder === -1 ?
            sortedArray.length :
            firstLargerThanRemainder;
        const smallerTotal = smallerCount > 0 ?
            utils_1.sum(sortedArray.splice(0, smallerCount), sizeOf) :
            0;
        elementTotal += smallerTotal;
        carry += smallerTotal;
        if (remainder < carry) {
            carry -= remainder;
        }
        else if (remainder > carry) {
            waste += remainder - carry;
            carry = 0;
        }
    }
    return Math.ceil((waste + elementTotal) / capacity);
}
exports.lowerBound2Sorted = lowerBound2Sorted;
