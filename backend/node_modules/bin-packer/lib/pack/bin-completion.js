"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binCompletion = void 0;
const prepare_values_1 = require("../util/prepare-values");
const utils_1 = require("../util/utils");
const bounds_1 = require("./bounds");
const fit_algos_1 = require("./fit-algos");
class CompletionNode {
    constructor(bin, size, depth, parent, parentWaste, tail, tailSum, capacity) {
        this.bin = bin;
        this.depth = depth;
        this.parent = parent;
        this.tail = tail;
        this.tailSum = tailSum;
        this.capacity = capacity;
        this.accumulatedWaste = parentWaste + capacity - size;
    }
    completionChildFrom(feasibleSet) {
        const childBin = [];
        const childTail = [];
        for (let i = 0; i < feasibleSet.tailStartIndex; ++i) {
            if (feasibleSet.includedIndexes[i] !== undefined) {
                childBin.push(feasibleSet.array[i]);
            }
            else {
                childTail.push(feasibleSet.array[i]);
            }
        }
        return new CompletionNode(childBin, feasibleSet.includedSum, this.depth + 1, this, this.accumulatedWaste, childTail.concat(feasibleSet.array.slice(feasibleSet.tailStartIndex, feasibleSet.array.length)), feasibleSet.tailSum, this.capacity);
    }
    assemblePacking() {
        const packing = [];
        let node = this;
        while (node.parent !== null) {
            packing.push(node.bin);
            node = node.parent;
        }
        return packing.reverse();
    }
}
class FeasibleSet {
    constructor(array, includedIndexes, includedSum, numIncludedIndexes, tailStartIndex, tailSum) {
        this.array = array;
        this.includedIndexes = includedIndexes;
        this.includedSum = includedSum;
        this.numIncludedIndexes = numIncludedIndexes;
        this.tailStartIndex = tailStartIndex;
        this.tailSum = tailSum;
    }
    makeChildIncluding(sizeOf, nextIncludedIndex) {
        if (nextIncludedIndex < this.tailStartIndex ||
            this.array.length <= nextIncludedIndex) {
            throw new Error('Can only include an element from the tail when creating ' +
                ' a new child');
        }
        const childIncludeIndexes = this.includedIndexes.slice();
        childIncludeIndexes[nextIncludedIndex] = nextIncludedIndex;
        const elementSize = sizeOf(this.array[nextIncludedIndex]);
        return new FeasibleSet(this.array, childIncludeIndexes, this.includedSum + elementSize, this.numIncludedIndexes + 1, nextIncludedIndex + 1, this.tailSum - elementSize);
    }
    makeChildNotIncluding(nextTailStartIndex) {
        if (nextTailStartIndex < this.tailStartIndex ||
            this.array.length < nextTailStartIndex) {
            throw new Error('Can not advance the tail past its length');
        }
        return new FeasibleSet(this.array, this.includedIndexes.slice(), this.includedSum, this.numIncludedIndexes, nextTailStartIndex, this.tailSum);
    }
    makeFeasibleChildren(sizeOf, capacity) {
        const children = [];
        let index = this.tailStartIndex;
        while (index < this.array.length) {
            const elementSize = sizeOf(this.array[index]);
            if (this.includedSum + elementSize <= capacity) {
                children.push(this.makeChildIncluding(sizeOf, index));
                break;
            }
            ++index;
        }
        if (index >= this.array.length - 1) {
            if (children.length === 0) {
                children.push(this.makeChildNotIncluding(this.array.length));
            }
        }
        else {
            children.push(this.makeChildNotIncluding(index + 1));
        }
        return children;
    }
}
class SolutionState {
    constructor(lowerBound, totalSize, capacity, bestSolution) {
        this.lowerBound = lowerBound;
        this.totalSize = totalSize;
        this.capacity = capacity;
        this.bestSolution = bestSolution;
        this.maxWaste = this.getMaxWaste();
    }
    get bestLength() {
        return this.bestSolution.length;
    }
    updateBestSolution(newBestSolution) {
        this.bestSolution = newBestSolution;
        this.maxWaste = this.getMaxWaste();
    }
    getMaxWaste() {
        return (this.bestLength - 1) * this.capacity - this.totalSize;
    }
    minCompletionSum(accumulatedWaste) {
        return this.capacity - (this.maxWaste - accumulatedWaste);
    }
}
function binCompletion(obj, sizeOf, capacity) {
    const { array: array, oversized: oversized } = prepare_values_1.prepareValues(obj, sizeOf, capacity);
    const descending = utils_1.sortDescending(array, sizeOf);
    const lowerBound = bounds_1.lowerBound2Sorted(descending.slice().reverse(), sizeOf, capacity);
    const bestSolution = fit_algos_1.bestFitDecreasingSorted(descending, sizeOf, capacity);
    if (lowerBound === bestSolution.length) {
        return {
            'bins': bestSolution,
            'oversized': oversized,
        };
    }
    else {
        const totalSize = utils_1.sum(descending, sizeOf);
        const solutionState = new SolutionState(lowerBound, totalSize, capacity, bestSolution);
        const lowerBoundSolution = nextCompletionLevel(new CompletionNode([], capacity, 0, null, 0, descending, totalSize, capacity), solutionState, sizeOf);
        return {
            'bins': lowerBoundSolution || solutionState.bestSolution,
            'oversized': oversized,
        };
    }
}
exports.binCompletion = binCompletion;
function nextCompletionLevel(completionNode, solutionState, sizeOf) {
    const nextDepth = completionNode.depth + 1;
    for (const feasibleSet of generateFeasibleSets(completionNode, solutionState, sizeOf)) {
        if (feasibleSet.numIncludedIndexes === feasibleSet.array.length) {
            if (nextDepth === solutionState.lowerBound) {
                return completionNode.completionChildFrom(feasibleSet).assemblePacking();
            }
            else {
                solutionState.updateBestSolution(completionNode.completionChildFrom(feasibleSet).assemblePacking());
            }
        }
        else {
            if (nextDepth + 1 < solutionState.bestLength) {
                const lowerBoundSolution = nextCompletionLevel(completionNode.completionChildFrom(feasibleSet), solutionState, sizeOf);
                if (lowerBoundSolution !== null) {
                    return lowerBoundSolution;
                }
            }
        }
    }
    return null;
}
function generateFeasibleSets(completionNode, solutionState, sizeOf) {
    const largestElementSize = sizeOf(completionNode.tail[0]);
    return recurseFeasibleSets(new FeasibleSet(completionNode.tail, [0,], largestElementSize, 1, 1, completionNode.tailSum - largestElementSize), sizeOf, solutionState.capacity, solutionState.minCompletionSum(completionNode.accumulatedWaste));
}
function recurseFeasibleSets(feasibleSet, sizeOf, capacity, minCompletionSum) {
    if (feasibleSet.includedSum === capacity) {
        return [feasibleSet,];
    }
    else if (feasibleSet.tailStartIndex >= feasibleSet.array.length) {
        if (feasibleSet.includedSum >= minCompletionSum) {
            return [feasibleSet,];
        }
        else {
            return [];
        }
    }
    else if (feasibleSet.includedSum + feasibleSet.tailSum >= minCompletionSum) {
        const children = feasibleSet.makeFeasibleChildren(sizeOf, capacity);
        const descendentSets = recurseFeasibleSets(children[0], sizeOf, capacity, minCompletionSum);
        if (children.length < 2) {
            return descendentSets;
        }
        else {
            return descendentSets.concat(recurseFeasibleSets(children[1], sizeOf, capacity, minCompletionSum));
        }
    }
    else {
        return [];
    }
}
